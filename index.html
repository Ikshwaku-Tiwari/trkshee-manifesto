<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRKSHEE | The Intellectual Gymnasium</title>
    <meta name="description"
        content="TRKSHEE - The Intellectual Gymnasium. In an age of infinite distraction, focus is the currency.">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- GSAP + ScrollTrigger -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>

    <!-- Lenis Smooth Scroll -->
    <script src="https://unpkg.com/lenis@1.1.18/dist/lenis.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            background: #000000;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: #000000;
            color: #ffffff;
            overflow-x: hidden;
        }

        /* Utility Classes (replacing Tailwind) */
        .text-center {
            text-align: center;
        }

        .text-sm {
            font-size: 0.875rem;
        }

        .text-3xl {
            font-size: 1.875rem;
        }

        .text-4xl {
            font-size: 2.25rem;
        }

        .text-5xl {
            font-size: 3rem;
        }

        .text-6xl {
            font-size: 3.75rem;
        }

        .font-bold {
            font-weight: 700;
        }

        .uppercase {
            text-transform: uppercase;
        }

        .tracking-tight {
            letter-spacing: -0.025em;
        }

        .mb-16 {
            margin-bottom: 4rem;
        }

        .mb-20 {
            margin-bottom: 5rem;
        }

        .py-20 {
            padding-top: 5rem;
            padding-bottom: 5rem;
        }

        .space-y-8>*+* {
            margin-top: 2rem;
        }

        .mx-auto {
            margin-left: auto;
            margin-right: auto;
        }

        .max-w-4xl {
            max-width: 56rem;
        }

        .w-full {
            width: 100%;
        }

        .flex-shrink-0 {
            flex-shrink: 0;
        }

        @media (min-width: 768px) {
            .md\:text-5xl {
                font-size: 3rem;
            }
        }

        @media (min-width: 1024px) {
            .lg\:text-6xl {
                font-size: 3.75rem;
            }
        }

        /* Preloader */
        .preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .preloader-counter {
            font-size: clamp(4rem, 15vw, 10rem);
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .preloader-text {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            opacity: 0.4;
            margin-top: 2rem;
        }

        /* WebGL Canvas */
        #webgl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        /* Background Overlay - DISABLED to show Three.js canvas */
        .bg-overlay {
            display: none;
        }

        /* Noise/Grain Overlay */
        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0.05;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* ============================================
           COGNITIVE CATALYST CURSOR SYSTEM
           ============================================ */

        /* Hide default cursor globally - DESKTOP ONLY */
        @media (hover: hover) and (pointer: fine) {
            * {
                cursor: none !important;
            }
        }

        /* Hide custom cursor on touch devices */
        @media (hover: none),
        (pointer: coarse) {

            .custom-cursor,
            .quantum-trace {
                display: none !important;
            }
        }

        /* Custom Cursor Container */
        .custom-cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 60px;
            height: 60px;
            pointer-events: none;
            z-index: 10000;
            transform: translate(-50%, -50%);
            mix-blend-mode: screen;
        }

        /* Singularity Dot - Central Core */
        .cursor-singularity {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #FF8C00 0%, #FF6B00 50%, rgba(255, 140, 0, 0.5) 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #FF8C00, 0 0 20px rgba(255, 140, 0, 0.5);
            transition: opacity 0.2s ease;
        }

        /* Rotating Bracket Frame */
        .cursor-bracket {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            border: 1px solid rgba(255, 255, 255, 0.6);
            transform: translate(-50%, -50%) rotate(0deg);
            animation: bracketRotate 8s linear infinite;
            transition: transform 0.3s cubic-bezier(0.23, 1, 0.32, 1),
                width 0.3s cubic-bezier(0.23, 1, 0.32, 1),
                height 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        }

        @keyframes bracketRotate {
            from {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Shatter Shards - Hidden by default */
        .cursor-shards {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .cursor-shard {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .cursor-shard:nth-child(1) {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: #FF8C00;
            box-shadow: 0 0 6px #FF8C00;
        }

        .cursor-shard:nth-child(2) {
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            background: #4B0082;
            box-shadow: 0 0 6px #4B0082;
        }

        .cursor-shard:nth-child(3) {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            background: #FF8C00;
            box-shadow: 0 0 6px #FF8C00;
        }

        .cursor-shard:nth-child(4) {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            background: #4B0082;
            box-shadow: 0 0 6px #4B0082;
        }

        /* Hover State - Shatter Effect */
        .custom-cursor.hovering .cursor-singularity {
            opacity: 0;
        }

        .custom-cursor.hovering .cursor-bracket {
            width: 50px;
            height: 50px;
            animation: none;
            transform: translate(-50%, -50%) rotate(45deg);
            border-color: rgba(255, 140, 0, 0.8);
        }

        .custom-cursor.hovering .cursor-shard {
            opacity: 1;
            animation: shardOrbit 2s linear infinite;
        }

        .custom-cursor.hovering .cursor-shard:nth-child(2) {
            animation-delay: 0.5s;
        }

        .custom-cursor.hovering .cursor-shard:nth-child(3) {
            animation-delay: 1s;
        }

        .custom-cursor.hovering .cursor-shard:nth-child(4) {
            animation-delay: 1.5s;
        }

        @keyframes shardOrbit {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.3);
            }
        }

        /* Click State - Pulse */
        .custom-cursor.clicking .cursor-bracket {
            transform: translate(-50%, -50%) rotate(45deg) scale(1.5);
            border-color: rgba(255, 140, 0, 1);
        }

        /* Click Burst Particles */
        .click-burst {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
        }

        .burst-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
        }

        /* Quantum Trace Trail */
        .quantum-trace {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9998;
            overflow: hidden;
        }

        .trace-point {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 140, 0, 0.4);
            border-radius: 50%;
            filter: blur(2px);
            pointer-events: none;
        }

        /* Magnetic class for cards */
        .magnetic {
            transition: transform 0.2s cubic-bezier(0.23, 1, 0.32, 1);
        }

        /* Technical Grid Overlay */
        .technical-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
            opacity: 0.02;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 100px 100px;
        }

        /* Data Tickers */
        .data-ticker {
            position: fixed;
            font-size: 0.625rem;
            font-family: 'Space Grotesk', monospace;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            opacity: 0.25;
            z-index: 100;
            pointer-events: none;
        }

        .ticker-tl {
            top: 2rem;
            left: 2rem;
        }

        .ticker-br {
            bottom: 2rem;
            right: 2rem;
            text-align: right;
        }

        /* Main Content Layer */
        main {
            position: relative;
            z-index: 10;
        }

        /* Sound Toggle */
        .sound-toggle {
            position: fixed;
            top: 2rem;
            right: 2rem;
            z-index: 100;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            opacity: 0.5;
            cursor: pointer;
            transition: opacity 0.3s ease;
            font-family: 'Space Grotesk', sans-serif;
        }

        .sound-toggle:hover {
            opacity: 1;
        }

        /* Section base styles */
        section {
            position: relative;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 4rem 2rem;
        }

        /* Hero Title */
        .hero-title {
            font-size: clamp(4rem, 20vw, 16rem);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: -0.02em;
            line-height: 0.85;
        }

        .hero-subtitle {
            font-size: clamp(0.875rem, 2vw, 1.25rem);
            font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 0.4em;
            opacity: 0.5;
            margin-top: 2rem;
        }

        /* Philosophy Text */
        .philosophy-line {
            font-size: clamp(1.25rem, 3vw, 2rem);
            font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            line-height: 2;
            opacity: 0;
        }

        /* Horizontal Scroll Section */
        .horizontal-wrapper {
            overflow: hidden;
        }

        .horizontal-container {
            display: flex;
            flex-wrap: nowrap;
            width: fit-content;
        }

        .algorithm-card {
            width: 320px;
            min-height: 400px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 2.5rem 2rem;
            margin: 0 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .algorithm-card.hero-card {
            background: linear-gradient(135deg, #5ADFDF 0%, #77EFBD 100%);
            color: #000000;
            border: none;
        }

        .card-time {
            font-size: 0.875rem;
            font-weight: 600;
            opacity: 0.6;
            margin-bottom: 1.5rem;
        }

        .hero-card .card-time {
            opacity: 0.8;
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2rem;
        }

        .card-item {
            font-size: 0.875rem;
            opacity: 0.7;
            margin-bottom: 0.75rem;
            text-align: left;
        }

        .hero-card .card-item {
            opacity: 0.9;
        }

        .card-arrow {
            position: absolute;
            right: -2rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            opacity: 0.3;
        }

        /* Philosophy Section */
        .philosophy-card {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4rem;
            max-width: 1000px;
        }

        .philosophy-content {
            text-align: left;
        }

        .philosophy-headline {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            margin-bottom: 1.5rem;
        }

        .philosophy-subtext {
            font-size: clamp(1rem, 2vw, 1.25rem);
            font-weight: 300;
            line-height: 1.8;
            opacity: 0.7;
            max-width: 500px;
        }

        /* Geometric Shape */
        .geometric-shape {
            width: 200px;
            height: 200px;
            flex-shrink: 0;
            animation: rotateShape 20s linear infinite;
        }

        @keyframes rotateShape {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Contact Links */
        .contact-link-wrapper {
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            padding: 2rem 0;
        }

        .contact-link-wrapper:last-child {
            border-bottom: none;
        }

        .contact-link {
            font-size: clamp(3rem, 10vw, 6rem);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            text-decoration: none;
            color: #ffffff;
            display: inline-flex;
            align-items: center;
            gap: 1.5rem;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .contact-link:hover {
            color: #5ADFDF;
            transform: translateX(1rem);
        }

        .contact-link .arrow {
            font-size: 0.5em;
            opacity: 0.6;
            transition: all 0.3s ease;
        }

        .contact-link:hover .arrow {
            opacity: 1;
            transform: translate(5px, -5px);
        }

        /* Footer */
        .footer-wrapper {
            position: relative;
            overflow: hidden;
            min-height: 60vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(to top, #000000 0%, rgba(0, 0, 0, 0.95) 40%, rgba(0, 0, 0, 0.7) 70%, transparent 100%);
            z-index: 20;
        }

        .footer-text {
            font-size: clamp(0.625rem, 1vw, 0.75rem);
            font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            color: rgba(255, 255, 255, 0.8);
            position: relative;
            z-index: 22;
        }

        .footer-giant-text {
            position: absolute;
            bottom: -5%;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(8rem, 30vw, 25rem);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: -0.02em;
            white-space: nowrap;
            -webkit-text-stroke: 2px rgba(255, 255, 255, 0.35);
            -webkit-text-fill-color: rgba(255, 255, 255, 0.05);
            z-index: 21;
        }

        /* Hero Sub-definition - matches subtitle style */
        .hero-sub-definition {
            font-size: clamp(0.75rem, 1.5vw, 1rem);
            font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 0.4em;
            opacity: 0.5;
            margin-top: 1rem;
        }

        /* Scroll Indicator - Minimalist */
        .scroll-indicator {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.625rem;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            opacity: 0.5;
            animation: scrollBounce 2s ease-in-out infinite;
        }

        .scroll-indicator .scroll-arrow {
            font-size: 1.25rem;
        }

        @keyframes scrollBounce {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            50% {
                transform: translateX(-50%) translateY(10px);
            }
        }

        /* Spacer */
        .spacer-10vw {
            width: 10vw;
            flex-shrink: 0;
        }

        /* Algorithm section override */
        .algorithm-section {
            padding: 0 !important;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 2px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .sound-toggle {
                top: 1rem;
                right: 1rem;
                font-size: 0.625rem;
            }

            section {
                padding: 3rem 1.5rem;
            }

            .algorithm-card {
                width: 280px;
                min-height: 350px;
                padding: 2rem 1.5rem;
            }

            .philosophy-card {
                flex-direction: column;
                gap: 2rem;
            }

            .philosophy-content {
                text-align: center;
            }

            .geometric-shape {
                width: 120px;
                height: 120px;
            }

            .data-ticker {
                display: none;
            }

            /* Mobile Footer Fixes */
            .footer-wrapper {
                min-height: 50vh;
                padding-bottom: 6rem;
            }

            .footer-giant-text {
                font-size: clamp(4rem, 20vw, 8rem);
                bottom: 1rem;
                -webkit-text-stroke: 1px rgba(255, 255, 255, 0.3);
            }

            .footer-text {
                font-size: 0.625rem;
                padding: 0 1rem;
                text-align: center;
                line-height: 1.6;
            }
        }
    </style>
</head>

<body>
    <!-- Preloader -->
    <div class="preloader" id="preloader">
        <div class="preloader-counter" id="preloader-counter">00%</div>
        <div class="preloader-text">SYSTEM INITIALIZING...</div>
    </div>

    <!-- WebGL Canvas (Three.js) -->
    <canvas id="webgl-canvas"></canvas>

    <!-- Background Overlay -->
    <div class="bg-overlay"></div>

    <!-- Technical Grid Overlay -->
    <div class="technical-grid"></div>

    <!-- Noise/Grain Overlay -->
    <div class="noise-overlay"></div>

    <!-- Custom Cursor System -->
    <div class="custom-cursor" id="custom-cursor">
        <div class="cursor-singularity"></div>
        <div class="cursor-bracket"></div>
        <div class="cursor-shards">
            <div class="cursor-shard"></div>
            <div class="cursor-shard"></div>
            <div class="cursor-shard"></div>
            <div class="cursor-shard"></div>
        </div>
    </div>
    <div class="quantum-trace" id="quantum-trace"></div>

    <!-- Data Tickers -->
    <div class="data-ticker ticker-tl">
        <div>SYS.STATUS</div>
        <div id="ticker-1">0x00000000</div>
    </div>
    <div class="data-ticker ticker-br">
        <div>NEURAL.SYNC</div>
        <div id="ticker-2">████████ 100%</div>
    </div>

    <!-- Sound Toggle -->
    <div class="sound-toggle" id="sound-toggle">
        SOUND [OFF]
    </div>

    <!-- Background Audio -->
    <audio id="ambient-audio" loop>
        <source src="ambient-soundscapes-007-space-atmosphere-304974.mp3" type="audio/mpeg">
    </audio>

    <!-- Main Content -->
    <main id="main-content" style="visibility: hidden;">

        <!-- Section 1: Hero -->
        <section id="hero">
            <div id="hero-content">
                <h1 class="hero-title" id="hero-title">TRKSHEE</h1>
                <p class="hero-subtitle" id="hero-subtitle">The Intellectual Gymnasium</p>
                <p class="hero-sub-definition">A Mentorship Service</p>
            </div>
            <!-- Scroll Indicator -->
            <div class="scroll-indicator">
                <span>SCROLL</span>
                <span class="scroll-arrow">↓</span>
            </div>
        </section>

        <!-- Section 2: The Manifesto -->
        <section id="manifesto">
            <div class="max-w-4xl mx-auto space-y-8">
                <p class="philosophy-line">In an age of infinite distraction,</p>
                <p class="philosophy-line">Focus is the currency.</p>
                <p class="philosophy-line" style="margin-top: 4rem;">We engineer cognitive revolution.</p>
                <p class="philosophy-line" style="margin-top: 4rem;">Credential ≠ Competence.</p>
            </div>
        </section>

        <!-- Section 3: The Algorithm (Horizontal Scroll) -->
        <section id="algorithm-section" class="algorithm-section">
            <div class="w-full py-20">
                <h2 class="text-center text-4xl font-bold uppercase tracking-tight mb-20">THE MASTERY ALGORITHM</h2>

                <div class="horizontal-wrapper" id="horizontal-wrapper">
                    <div class="horizontal-container" id="horizontal-container">
                        <div class="spacer-10vw"></div>

                        <div class="algorithm-card">
                            <div class="card-time">[10-15] mins</div>
                            <h3 class="card-title">THE CONNECTION</h3>
                            <p class="card-item">&gt; Diagnostic mapping</p>
                            <p class="card-item">&gt; Identify gaps</p>
                            <span class="card-arrow">→</span>
                        </div>

                        <div class="algorithm-card">
                            <div class="card-time">[30-40] mins</div>
                            <h3 class="card-title">FIRST PRINCIPLES</h3>
                            <p class="card-item">&gt; Deep technical dive</p>
                            <p class="card-item">&gt; Analogies & Core Logic</p>
                            <span class="card-arrow">→</span>
                        </div>

                        <div class="algorithm-card">
                            <div class="card-time">[15-20] mins</div>
                            <h3 class="card-title">SPARRING</h3>
                            <p class="card-item">&gt; Challenges</p>
                            <p class="card-item">&gt; Stress-test ideas</p>
                            <span class="card-arrow">→</span>
                        </div>

                        <div class="algorithm-card hero-card">
                            <div class="card-time">[10-15] mins</div>
                            <h3 class="card-title">TEACH-BACK</h3>
                            <p class="card-item">&gt; Student becomes Teacher</p>
                            <p class="card-item">&gt; Verified Mastery</p>
                            <span class="card-arrow" style="color: #000;">→</span>
                        </div>

                        <div class="algorithm-card">
                            <div class="card-time">[10-20] mins</div>
                            <h3 class="card-title">DOUBTS & INDUSTRY</h3>
                            <p class="card-item">&gt; Market Relevance</p>
                            <p class="card-item">&gt; Closing Loop</p>
                        </div>

                        <div class="spacer-10vw"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: The Philosophy -->
        <section id="philosophy-section">
            <div class="philosophy-card" id="philosophy-card">
                <div class="geometric-shape">
                    <svg viewBox="0 0 200 200" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="100,10 170,40 190,100 170,160 100,190 30,160 10,100 30,40"
                            stroke="rgba(255,255,255,0.3)" stroke-width="1" fill="none" />
                        <polygon points="100,40 140,55 155,100 140,145 100,160 60,145 45,100 60,55"
                            stroke="rgba(255,255,255,0.2)" stroke-width="1" fill="none" />
                        <polygon points="100,70 130,100 100,130 70,100" stroke="rgba(90,223,223,0.4)" stroke-width="1"
                            fill="none" />
                        <line x1="100" y1="10" x2="100" y2="190" stroke="rgba(255,255,255,0.1)" stroke-width="0.5" />
                        <line x1="10" y1="100" x2="190" y2="100" stroke="rgba(255,255,255,0.1)" stroke-width="0.5" />
                        <line x1="30" y1="40" x2="170" y2="160" stroke="rgba(255,255,255,0.08)" stroke-width="0.5" />
                        <line x1="170" y1="40" x2="30" y2="160" stroke="rgba(255,255,255,0.08)" stroke-width="0.5" />
                    </svg>
                </div>

                <div class="philosophy-content">
                    <h2 class="philosophy-headline">WE REJECT THE PARROT.</h2>
                    <p class="philosophy-subtext">
                        The operator follows instructions. The architect questions premises.
                        Trkshee is the forge where memory is transmuted into mastery.
                    </p>
                </div>
            </div>
        </section>

        <!-- Section 5: Join The Network -->
        <section id="contact">
            <div class="w-full max-w-4xl mx-auto">
                <h2 class="text-sm uppercase mb-16 text-center" style="letter-spacing: 0.3em; opacity: 0.4;">Join The
                    Network</h2>

                <div class="contact-link-wrapper">
                    <a href="https://instagram.com/trkshee_official" target="_blank" rel="noopener noreferrer"
                        class="contact-link">
                        INSTAGRAM <span class="arrow">↗</span>
                    </a>
                </div>
                <div class="contact-link-wrapper">
                    <a href="mailto:trkshee.main@gmail.com" class="contact-link">
                        EMAIL <span class="arrow">↗</span>
                    </a>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer class="footer-wrapper">
            <p class="footer-text">EST. 2025 // BUILDING ARCHITECTS OF THE FUTURE</p>
            <div class="footer-giant-text">TRKSHEE</div>
        </footer>

    </main>

    <script>
        // Check if required libraries loaded
        if (typeof THREE === 'undefined') {
            console.error('Three.js failed to load');
        }
        if (typeof gsap === 'undefined') {
            console.error('GSAP failed to load');
        }
        if (typeof Lenis === 'undefined') {
            console.error('Lenis failed to load');
        }

        // Register GSAP plugins
        gsap.registerPlugin(ScrollTrigger);

        // Initialize Lenis smooth scroll
        const lenis = new Lenis({
            lerp: 0.05,
            duration: 2.0,
            easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
            orientation: 'vertical',
            gestureOrientation: 'vertical',
            smoothWheel: true,
            wheelMultiplier: 0.6,
            touchMultiplier: 1.2,
        });

        lenis.on('scroll', ScrollTrigger.update);
        gsap.ticker.add((time) => { lenis.raf(time * 1000); });
        gsap.ticker.lagSmoothing(0);
        lenis.stop();

        // ============================================
        // THREE.JS SPACE SCENE - SUPERNOVA 1987A DAMRU
        // ============================================
        let scene, camera, renderer;
        let starfield, damruGroup, innerRingPoints, outerLobesPoints, coreGlow;
        let scrollProgress = 0;
        let starfieldOriginalPositions = null;
        let animationTime = 0;

        // Color Palette
        const AMBER = 0xFF8C00;
        const INDIGO = 0x4B0082;
        const WHITE = 0xFFFFFF;

        // Mobile detection for Three.js responsive adjustments
        const isMobileView = window.innerWidth < 768;
        const damruScale = isMobileView ? 0.6 : 1.0;
        const cameraFOV = isMobileView ? 75 : 60; // Wider FOV on mobile to see more
        const initialCameraZ = isMobileView ? 600 : 800;

        function initThreeJS() {
            const canvas = document.getElementById('webgl-canvas');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(cameraFOV, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = initialCameraZ;

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            createStarfield();
            createDamru();
            animateThreeJS();

            window.addEventListener('resize', onWindowResize);
            console.log('Three.js initialized with Supernova 1987A Damru');
        }

        function createStarfield() {
            const starCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);

            const cyanColor = new THREE.Color(0x5ADFDF);
            const whiteColor = new THREE.Color(0xffffff);
            const amberColor = new THREE.Color(AMBER);

            // Responsive starfield - smaller sphere on mobile so stars are visible
            const starRadius = isMobileView ? 500 : 800;
            const starZOffset = isMobileView ? 0 : -200;

            for (let i = 0; i < starCount; i++) {
                const radius = starRadius;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi) + starZOffset;


                // Mix of cyan, white, and occasional amber stars
                const rand = Math.random();
                let color;
                if (rand < 0.1) {
                    color = cyanColor;
                } else if (rand < 0.15) {
                    color = amberColor;
                } else {
                    color = whiteColor;
                }
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Store original positions for gravitation effect
            starfieldOriginalPositions = new Float32Array(positions);

            const material = new THREE.PointsMaterial({
                size: 4,
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                sizeAttenuation: true
            });

            starfield = new THREE.Points(geometry, material);
            scene.add(starfield);
        }

        function createDamru() {
            damruGroup = new THREE.Group();
            damruGroup.position.z = isMobileView ? -250 : -400;
            damruGroup.position.y = isMobileView ? 0 : -50;

            // Apply mobile scale
            damruGroup.scale.set(damruScale, damruScale, damruScale);

            // Create outer lobes (hyperboloid of one sheet)
            createOuterLobes();

            // Create inner ring (torus at waist)
            createInnerRing();

            // Create central core glow
            createCoreGlow();

            scene.add(damruGroup);
        }

        function createOuterLobes() {
            const lobePointCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(lobePointCount * 3);
            const colors = new Float32Array(lobePointCount * 3);
            const sizes = new Float32Array(lobePointCount);

            const amberColor = new THREE.Color(AMBER);
            const indigoColor = new THREE.Color(INDIGO);
            const whiteColor = new THREE.Color(WHITE);

            // Hyperboloid of one sheet: x² + y² - z² = 1
            // Parametric: x = a*cosh(v)*cos(u), y = a*cosh(v)*sin(u), z = c*sinh(v)
            const scale = 60;
            const heightScale = 100;

            for (let i = 0; i < lobePointCount; i++) {
                const u = Math.random() * Math.PI * 2; // Angle around axis
                const v = (Math.random() - 0.5) * 3; // Height parameter (-1.5 to 1.5)

                // Hyperboloid equation with some noise for organic feel
                const coshV = Math.cosh(v);
                const sinhV = Math.sinh(v);
                const noise = 1 + (Math.random() - 0.5) * 0.15;

                const x = scale * coshV * Math.cos(u) * noise;
                const y = scale * coshV * Math.sin(u) * noise;
                const z = heightScale * sinhV;

                positions[i * 3] = x;
                positions[i * 3 + 1] = z; // Swap y and z for vertical orientation
                positions[i * 3 + 2] = y;

                // Color gradient: indigo at the outer tips, amber near the waist
                const distanceFromWaist = Math.abs(v);
                const t = Math.min(distanceFromWaist / 1.5, 1);

                // Blend from amber (center) to indigo (edges) with some white highlights
                let color;
                if (Math.random() < 0.08) {
                    // Occasional white sparkle
                    color = whiteColor.clone();
                } else {
                    color = new THREE.Color().lerpColors(amberColor, indigoColor, t * t);
                }

                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                // Variable particle sizes: larger near waist, smaller at tips
                sizes[i] = 2 + (1 - t) * 4 + Math.random() * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // Custom shader material for variable sizes
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    opacity: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float opacity;
                    varying vec3 vColor;
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.3, 0.5, r);
                        gl_FragColor = vec4(vColor, alpha * opacity);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            outerLobesPoints = new THREE.Points(geometry, material);
            outerLobesPoints.userData.isOuterLobes = true;
            damruGroup.add(outerLobesPoints);
        }

        function createInnerRing() {
            const ringPointCount = 800;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(ringPointCount * 3);
            const colors = new Float32Array(ringPointCount * 3);
            const sizes = new Float32Array(ringPointCount);

            const amberColor = new THREE.Color(AMBER);
            const whiteColor = new THREE.Color(WHITE);

            // Torus shape at the waist (z = 0 plane)
            const majorRadius = 60; // Distance from center to ring center
            const minorRadius = 8;  // Thickness of the ring tube

            for (let i = 0; i < ringPointCount; i++) {
                const u = Math.random() * Math.PI * 2; // Angle around the ring
                const v = Math.random() * Math.PI * 2; // Angle around the tube
                const noise = 1 + (Math.random() - 0.5) * 0.1;

                const x = (majorRadius + minorRadius * Math.cos(v)) * Math.cos(u) * noise;
                const z = (majorRadius + minorRadius * Math.cos(v)) * Math.sin(u) * noise;
                const y = minorRadius * Math.sin(v) * noise; // This stays small (tube thickness)

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                // Bright white/amber colors for the inner ring
                const t = Math.random();
                const color = t < 0.6 ? whiteColor.clone() : amberColor.clone();
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                // Bright, consistent sizes for the ring
                sizes[i] = 3 + Math.random() * 3;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    opacity: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float opacity;
                    varying vec3 vColor;
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.2, 0.5, r);
                        gl_FragColor = vec4(vColor, alpha * opacity * 1.2);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            innerRingPoints = new THREE.Points(geometry, material);
            innerRingPoints.userData.isInnerRing = true;
            damruGroup.add(innerRingPoints);
        }

        function createCoreGlow() {
            // Create radial gradient texture for volumetric glow
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, 'rgba(255, 200, 100, 0.8)');
            gradient.addColorStop(0.2, 'rgba(255, 140, 0, 0.5)');
            gradient.addColorStop(0.5, 'rgba(255, 100, 50, 0.2)');
            gradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending
            });

            coreGlow = new THREE.Sprite(spriteMaterial);
            coreGlow.scale.set(180, 180, 1);
            coreGlow.userData.isCoreGlow = true;
            damruGroup.add(coreGlow);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animateThreeJS() {
            requestAnimationFrame(animateThreeJS);
            animationTime += 0.016; // ~60fps time increment

            // Starfield slow rotation
            if (starfield) {
                starfield.rotation.y += 0.0002;
                starfield.rotation.x += 0.0001;
            }

            // Damru animations
            if (damruGroup) {
                // Gentle floating motion (sine wave)
                damruGroup.position.x = Math.sin(animationTime * 0.5) * 5;
                damruGroup.position.y = -50 + Math.sin(animationTime * 0.3) * 8;

                // Outer lobes slow rotation
                if (outerLobesPoints) {
                    outerLobesPoints.rotation.y += 0.002;
                }

                // Inner ring faster rotation (3x speed)
                if (innerRingPoints) {
                    innerRingPoints.rotation.y += 0.006;
                }

                // Core glow subtle pulsing
                if (coreGlow) {
                    const pulse = 1 + Math.sin(animationTime * 2) * 0.1;
                    coreGlow.scale.set(180 * pulse, 180 * pulse, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // Initialize Three.js
        initThreeJS();

        // Scroll-linked camera and Damru animation
        ScrollTrigger.create({
            trigger: 'body',
            start: 'top top',
            end: 'bottom bottom',
            scrub: 1.5,
            onUpdate: (self) => {
                scrollProgress = self.progress;

                // Camera zoom through the ring center (responsive)
                const startZ = initialCameraZ;
                const endZ = isMobileView ? 50 : -50; // Don't go as far through on mobile
                camera.position.z = startZ - (scrollProgress * (startZ - endZ));

                // Damru opacity and effects
                if (damruGroup) {
                    const damruOpacity = Math.max(0, Math.min(1, (scrollProgress - 0.15) / 0.25));

                    // Update outer lobes opacity and pulsing scale
                    if (outerLobesPoints && outerLobesPoints.material.uniforms) {
                        outerLobesPoints.material.uniforms.opacity.value = damruOpacity * 0.85;

                        // Lobes expand slightly as user scrolls
                        const pulseScale = 1 + scrollProgress * 0.15;
                        outerLobesPoints.scale.set(pulseScale, 1 + scrollProgress * 0.1, pulseScale);
                    }

                    // Inner ring higher opacity
                    if (innerRingPoints && innerRingPoints.material.uniforms) {
                        const ringOpacity = Math.max(0, Math.min(1, (scrollProgress - 0.2) / 0.2));
                        innerRingPoints.material.uniforms.opacity.value = ringOpacity * 1.0;
                    }

                    // Core glow
                    if (coreGlow) {
                        const glowOpacity = Math.max(0, Math.min(1, (scrollProgress - 0.25) / 0.2));
                        coreGlow.material.opacity = glowOpacity * 0.7;
                    }

                    // Move Damru toward camera as we scroll (responsive)
                    const damruStartZ = isMobileView ? -250 : -400;
                    const damruTravelDist = isMobileView ? 300 : 450;
                    damruGroup.position.z = damruStartZ + (scrollProgress * damruTravelDist);
                }

                // Starfield gravitation toward Damru center
                if (starfield && starfieldOriginalPositions) {
                    const positions = starfield.geometry.attributes.position.array;
                    const gravitationStrength = scrollProgress * 0.3;

                    // Target point (Damru center in world coordinates)
                    const targetX = damruGroup ? damruGroup.position.x : 0;
                    const targetY = damruGroup ? damruGroup.position.y : -50;
                    const targetZ = damruGroup ? damruGroup.position.z : -400;

                    for (let i = 0; i < positions.length; i += 3) {
                        const origX = starfieldOriginalPositions[i];
                        const origY = starfieldOriginalPositions[i + 1];
                        const origZ = starfieldOriginalPositions[i + 2];

                        // Interpolate toward Damru center
                        positions[i] = origX + (targetX - origX) * gravitationStrength;
                        positions[i + 1] = origY + (targetY - origY) * gravitationStrength;
                        positions[i + 2] = origZ + (targetZ - origZ) * gravitationStrength;
                    }

                    starfield.geometry.attributes.position.needsUpdate = true;

                    // Scale starfield
                    const scale = 1 + scrollProgress * 0.2;
                    starfield.scale.set(scale, scale, scale);
                }
            }
        });

        // Data Tickers
        function updateTickers() {
            const ticker1 = document.getElementById('ticker-1');
            const ticker2 = document.getElementById('ticker-2');

            const hex = '0x' + Math.floor(Math.random() * 0xFFFFFFFF).toString(16).toUpperCase().padStart(8, '0');
            ticker1.textContent = hex;

            const progress = Math.floor(Math.random() * 20 + 80);
            const bars = '█'.repeat(Math.floor(progress / 12.5)) + '░'.repeat(8 - Math.floor(progress / 12.5));
            ticker2.textContent = bars + ' ' + progress + '%';
        }

        setInterval(updateTickers, 2000);
        updateTickers();

        // Preloader
        const preloader = document.getElementById('preloader');
        const preloaderCounter = document.getElementById('preloader-counter');
        const mainContent = document.getElementById('main-content');

        let counter = { value: 0 };

        const preloaderTL = gsap.timeline({
            onComplete: () => { lenis.start(); }
        });

        preloaderTL.to(counter, {
            value: 100,
            duration: 3,
            ease: 'power2.inOut',
            onUpdate: () => {
                const val = Math.round(counter.value);
                preloaderCounter.textContent = (val < 10 ? '0' : '') + val + '%';
            }
        });

        preloaderTL.to(preloader, {
            yPercent: -100,
            duration: 1.2,
            ease: 'power4.inOut'
        }, '+=0.5');

        preloaderTL.set(mainContent, { visibility: 'visible' }, '-=1.2');

        preloaderTL.from('#hero-title', {
            y: 100,
            opacity: 0,
            duration: 1.5,
            ease: 'power3.out'
        }, '-=0.6');

        preloaderTL.from('#hero-subtitle', {
            y: 50,
            opacity: 0,
            duration: 1,
            ease: 'power3.out'
        }, '-=1');

        // Sound Toggle
        const soundToggle = document.getElementById('sound-toggle');
        const ambientAudio = document.getElementById('ambient-audio');
        let isSoundOn = false;

        ambientAudio.volume = 0.4;

        soundToggle.addEventListener('click', () => {
            isSoundOn = !isSoundOn;
            if (isSoundOn) {
                ambientAudio.play();
                soundToggle.textContent = 'SOUND [ON]';
            } else {
                ambientAudio.pause();
                soundToggle.textContent = 'SOUND [OFF]';
            }
        });

        // Hero Parallax
        gsap.to('#hero-content', {
            yPercent: 50,
            opacity: 0.3,
            ease: 'none',
            scrollTrigger: {
                trigger: '#hero',
                start: 'top top',
                end: 'bottom top',
                scrub: 1
            }
        });

        // Manifesto Scroll Reveal
        const philosophyLines = document.querySelectorAll('.philosophy-line');
        philosophyLines.forEach((line) => {
            gsap.to(line, {
                opacity: 1,
                y: 0,
                duration: 1.2,
                ease: 'power2.out',
                scrollTrigger: {
                    trigger: line,
                    start: 'top 75%',
                    end: 'top 50%',
                    toggleActions: 'play none none reverse'
                }
            });
            gsap.set(line, { y: 40 });
        });

        // Horizontal Scroll
        const horizontalContainer = document.getElementById('horizontal-container');
        const getScrollDistance = () => horizontalContainer.scrollWidth - window.innerWidth;

        gsap.to(horizontalContainer, {
            x: () => -getScrollDistance(),
            ease: 'none',
            scrollTrigger: {
                trigger: '#algorithm-section',
                start: 'top top',
                end: () => `+=${getScrollDistance()}`,
                pin: true,
                scrub: 1.5,
                invalidateOnRefresh: true,
                anticipatePin: 1
            }
        });

        const cards = document.querySelectorAll('.algorithm-card');
        cards.forEach((card, index) => {
            gsap.from(card, {
                opacity: 0,
                y: 30,
                duration: 0.8,
                scrollTrigger: {
                    trigger: '#algorithm-section',
                    start: `top+=${index * 100} 80%`,
                    toggleActions: 'play none none reverse'
                }
            });
        });

        // Philosophy Section
        gsap.from('#philosophy-card', {
            opacity: 0,
            y: 60,
            duration: 1.2,
            ease: 'power3.out',
            scrollTrigger: {
                trigger: '#philosophy-section',
                start: 'top 60%',
                toggleActions: 'play none none reverse'
            }
        });

        // Contact Links
        gsap.from('#contact .contact-link', {
            y: 30,
            stagger: 0.15,
            duration: 0.8,
            ease: 'power3.out',
            scrollTrigger: {
                trigger: '#contact',
                start: 'top 80%',
                toggleActions: 'play none none none'
            }
        });

        // Footer Animation
        gsap.from('.footer-giant-text', {
            yPercent: 30,
            opacity: 0,
            scrollTrigger: {
                trigger: '.footer-wrapper',
                start: 'top 80%',
                end: 'bottom bottom',
                scrub: 1
            }
        });

        window.addEventListener('resize', () => { ScrollTrigger.refresh(); });

        // ============================================
        // COGNITIVE CATALYST CURSOR SYSTEM
        // ============================================

        // Detect touch/mobile devices
        const isTouchDevice = (
            'ontouchstart' in window ||
            navigator.maxTouchPoints > 0 ||
            window.matchMedia('(hover: none)').matches
        );

        const customCursor = document.getElementById('custom-cursor');
        const quantumTrace = document.getElementById('quantum-trace');

        // Only initialize cursor system on non-touch devices
        if (!isTouchDevice && customCursor) {

            // Cursor position state
            let cursorX = window.innerWidth / 2;
            let cursorY = window.innerHeight / 2;
            let targetX = cursorX;
            let targetY = cursorY;

            // Normalized cursor position for Three.js (-1 to 1)
            let normalizedCursorX = 0;
            let normalizedCursorY = 0;

            // Gravity well strength
            const GRAVITY_STRENGTH = 0.015;

            // Quantum trace points
            const tracePoints = [];
            const MAX_TRACE_POINTS = 15;
            let traceFrameCount = 0;

            // GSAP quick setters for performance
            const setCursorX = gsap.quickTo(customCursor, 'left', { duration: 0.15, ease: 'power2.out' });
            const setCursorY = gsap.quickTo(customCursor, 'top', { duration: 0.15, ease: 'power2.out' });

            // Track mouse movement
            document.addEventListener('mousemove', (e) => {
                targetX = e.clientX;
                targetY = e.clientY;

                // Apply magnetic effect for cards
                const magneticCards = document.querySelectorAll('.algorithm-card, .contact-link');
                let magneticOffsetX = 0;
                let magneticOffsetY = 0;

                magneticCards.forEach(card => {
                    const rect = card.getBoundingClientRect();
                    const cardCenterX = rect.left + rect.width / 2;
                    const cardCenterY = rect.top + rect.height / 2;
                    const distance = Math.hypot(targetX - cardCenterX, targetY - cardCenterY);

                    if (distance < 120) {
                        const strength = (120 - distance) / 120 * 0.3;
                        magneticOffsetX += (cardCenterX - targetX) * strength;
                        magneticOffsetY += (cardCenterY - targetY) * strength;
                    }
                });

                // Apply magnetic offset
                targetX += magneticOffsetX;
                targetY += magneticOffsetY;

                // Update normalized coordinates for Three.js
                normalizedCursorX = (e.clientX / window.innerWidth) * 2 - 1;
                normalizedCursorY = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            // Smooth cursor following
            function updateCursor() {
                // Lerp cursor position
                cursorX += (targetX - cursorX) * 0.2;
                cursorY += (targetY - cursorY) * 0.2;

                setCursorX(cursorX);
                setCursorY(cursorY);

                // Update quantum trace
                traceFrameCount++;
                if (traceFrameCount % 3 === 0) { // Every 3 frames
                    addTracePoint(cursorX, cursorY);
                }

                requestAnimationFrame(updateCursor);
            }
            updateCursor();

            // Quantum Trace Trail
            function addTracePoint(x, y) {
                const point = document.createElement('div');
                point.className = 'trace-point';
                point.style.left = x + 'px';
                point.style.top = y + 'px';
                quantumTrace.appendChild(point);
                tracePoints.push(point);

                // Animate fade out
                gsap.to(point, {
                    opacity: 0,
                    scale: 0.3,
                    duration: 0.8,
                    ease: 'power2.out',
                    onComplete: () => {
                        point.remove();
                        const index = tracePoints.indexOf(point);
                        if (index > -1) tracePoints.splice(index, 1);
                    }
                });

                // Remove excess points
                while (tracePoints.length > MAX_TRACE_POINTS) {
                    const oldPoint = tracePoints.shift();
                    oldPoint.remove();
                }
            }

            // Hover detection for interactive elements
            const interactiveElements = document.querySelectorAll('a, button, .algorithm-card, .contact-link, .sound-toggle');

            interactiveElements.forEach(el => {
                el.addEventListener('mouseenter', () => {
                    customCursor.classList.add('hovering');
                });

                el.addEventListener('mouseleave', () => {
                    customCursor.classList.remove('hovering');
                });
            });

            // Click burst effect
            document.addEventListener('mousedown', (e) => {
                customCursor.classList.add('clicking');
                createClickBurst(e.clientX, e.clientY);
            });

            document.addEventListener('mouseup', () => {
                customCursor.classList.remove('clicking');
            });

            function createClickBurst(x, y) {
                const colors = ['#FF8C00', '#4B0082', '#FF6B00', '#9400D3', '#FFFFFF'];
                const particleCount = 8;

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'burst-particle';
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                    particle.style.boxShadow = `0 0 6px ${particle.style.background}`;
                    document.body.appendChild(particle);

                    const angle = (i / particleCount) * Math.PI * 2;
                    const velocity = 50 + Math.random() * 50;
                    const targetX = x + Math.cos(angle) * velocity;
                    const targetY = y + Math.sin(angle) * velocity;

                    gsap.to(particle, {
                        left: targetX,
                        top: targetY,
                        opacity: 0,
                        scale: 0,
                        duration: 0.6 + Math.random() * 0.3,
                        ease: 'power2.out',
                        onComplete: () => particle.remove()
                    });
                }
            }

            // Gravity Well - Integrate with Three.js animation loop
            // Override the animateThreeJS function to include cursor gravity
            const originalAnimateThreeJS = animateThreeJS;

            function animateThreeJSWithGravity() {
                requestAnimationFrame(animateThreeJSWithGravity);
                animationTime += 0.016;

                // Starfield slow rotation
                if (starfield) {
                    starfield.rotation.y += 0.0002;
                    starfield.rotation.x += 0.0001;

                    // Apply cursor gravity to starfield
                    if (starfieldOriginalPositions) {
                        const positions = starfield.geometry.attributes.position.array;

                        // Convert cursor to 3D world approximate position
                        const cursorWorldX = normalizedCursorX * 400;
                        const cursorWorldY = normalizedCursorY * 300;

                        for (let i = 0; i < positions.length; i += 3) {
                            const origX = starfieldOriginalPositions[i];
                            const origY = starfieldOriginalPositions[i + 1];
                            const origZ = starfieldOriginalPositions[i + 2];

                            // Base gravitation from scroll
                            const targetX = damruGroup ? damruGroup.position.x : 0;
                            const targetY = damruGroup ? damruGroup.position.y : -50;
                            const targetZ = damruGroup ? damruGroup.position.z : -400;
                            const gravitationStrength = scrollProgress * 0.3;

                            // Calculate base position with scroll gravitation
                            let newX = origX + (targetX - origX) * gravitationStrength;
                            let newY = origY + (targetY - origY) * gravitationStrength;
                            let newZ = origZ + (targetZ - origZ) * gravitationStrength;

                            // Add cursor gravity effect (subtle)
                            const distToCursor = Math.hypot(newX - cursorWorldX, newY - cursorWorldY);
                            if (distToCursor < 200) {
                                const cursorGravity = (200 - distToCursor) / 200 * GRAVITY_STRENGTH;
                                newX += (cursorWorldX - newX) * cursorGravity;
                                newY += (cursorWorldY - newY) * cursorGravity;
                            }

                            positions[i] = newX;
                            positions[i + 1] = newY;
                            positions[i + 2] = newZ;
                        }

                        starfield.geometry.attributes.position.needsUpdate = true;
                    }
                }

                // Damru animations with cursor gravity
                if (damruGroup) {
                    // Gentle floating motion (sine wave)
                    const baseX = Math.sin(animationTime * 0.5) * 5;
                    const baseY = -50 + Math.sin(animationTime * 0.3) * 8;

                    // Add subtle cursor attraction
                    const cursorWorldX = normalizedCursorX * 30;
                    const cursorWorldY = normalizedCursorY * 30;

                    damruGroup.position.x = baseX + cursorWorldX * 0.1;
                    damruGroup.position.y = baseY + cursorWorldY * 0.1;

                    // Outer lobes slow rotation
                    if (outerLobesPoints) {
                        outerLobesPoints.rotation.y += 0.002;
                    }

                    // Inner ring faster rotation (3x speed)
                    if (innerRingPoints) {
                        innerRingPoints.rotation.y += 0.006;
                    }

                    // Core glow subtle pulsing
                    if (coreGlow) {
                        const pulse = 1 + Math.sin(animationTime * 2) * 0.1;
                        coreGlow.scale.set(180 * pulse, 180 * pulse, 1);
                    }
                }

                renderer.render(scene, camera);
            }

            // Replace the animation loop (stop old one, start new one)
            // Note: We can't truly "stop" requestAnimationFrame, but we can redirect
            // The new function will take over rendering
            animateThreeJSWithGravity();

            // Add magnetic class to algorithm cards
            document.querySelectorAll('.algorithm-card').forEach(card => {
                card.classList.add('magnetic');
            });

            console.log('Cognitive Catalyst Cursor System initialized');

        } // End of !isTouchDevice check

        // Touch device fallback - just add a simple touch burst effect
        if (isTouchDevice) {
            document.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                if (touch) {
                    // Simple touch feedback particle burst
                    const colors = ['#FF8C00', '#4B0082'];
                    for (let i = 0; i < 4; i++) {
                        const particle = document.createElement('div');
                        particle.style.cssText = `
                            position: fixed;
                            left: ${touch.clientX}px;
                            top: ${touch.clientY}px;
                            width: 8px;
                            height: 8px;
                            background: ${colors[i % 2]};
                            border-radius: 50%;
                            pointer-events: none;
                            z-index: 9999;
                        `;
                        document.body.appendChild(particle);

                        const angle = (i / 4) * Math.PI * 2;
                        const targetX = touch.clientX + Math.cos(angle) * 40;
                        const targetY = touch.clientY + Math.sin(angle) * 40;

                        gsap.to(particle, {
                            left: targetX,
                            top: targetY,
                            opacity: 0,
                            duration: 0.4,
                            ease: 'power2.out',
                            onComplete: () => particle.remove()
                        });
                    }
                }
            }, { passive: true });

            console.log('Touch device detected - cursor system disabled, touch effects enabled');
        }
    </script>
</body>

</html>